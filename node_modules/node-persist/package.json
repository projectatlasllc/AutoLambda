{
  "_args": [
    [
      {
        "raw": "node-persist@2.0.11",
        "scope": null,
        "escapedName": "node-persist",
        "name": "node-persist",
        "rawSpec": "2.0.11",
        "spec": "2.0.11",
        "type": "version"
      },
      "/Users/raviteja/Documents/Projects/AutoLambda"
    ]
  ],
  "_from": "node-persist@2.0.11",
  "_id": "node-persist@2.0.11",
  "_inCache": true,
  "_location": "/node-persist",
  "_nodeVersion": "6.9.2",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/node-persist-2.0.11.tgz_1493209499468_0.7483972711488605"
  },
  "_npmUser": {
    "name": "akhoury",
    "email": "bentael@gmail.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "node-persist@2.0.11",
    "scope": null,
    "escapedName": "node-persist",
    "name": "node-persist",
    "rawSpec": "2.0.11",
    "spec": "2.0.11",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/node-persist/-/node-persist-2.0.11.tgz",
  "_shasum": "e01e2630d44771e2b1f33227d422e13e49e4e18a",
  "_shrinkwrap": null,
  "_spec": "node-persist@2.0.11",
  "_where": "/Users/raviteja/Documents/Projects/AutoLambda",
  "bugs": {
    "url": "https://github.com/simonlast/node-persist/issues"
  },
  "contributors": [
    {
      "name": "Simon Last",
      "email": "hello@simonlast.org",
      "url": "http://simonlast.org/"
    },
    {
      "name": "Ben Monro",
      "url": "https://github.com/benmonro"
    },
    {
      "name": "Aziz Khoury",
      "url": "https://github.com/akhoury"
    }
  ],
  "dependencies": {
    "mkdirp": "~0.5.1",
    "q": "~1.1.1"
  },
  "description": "Super-easy (and fast) persistent data structures in Node.js, modeled after HTML5 localStorage",
  "devDependencies": {
    "chai": "^3.5.0",
    "mocha": "^2.3.3",
    "rimraf": "^2.4.3"
  },
  "directories": {
    "example": "examples"
  },
  "dist": {
    "shasum": "e01e2630d44771e2b1f33227d422e13e49e4e18a",
    "tarball": "https://registry.npmjs.org/node-persist/-/node-persist-2.0.11.tgz"
  },
  "gitHead": "2d6e14601b0e960b507e1b2a961079676e8ce103",
  "homepage": "https://github.com/simonlast/node-persist#readme",
  "keywords": [
    "node",
    "persist",
    "storage"
  ],
  "license": "MIT",
  "main": "./src/node-persist.js",
  "maintainers": [
    {
      "name": "akhoury",
      "email": "bentael@gmail.com"
    },
    {
      "name": "benmonro",
      "email": "ben.monro@gmail.com"
    },
    {
      "name": "slast",
      "email": "hello@simonlast.org"
    }
  ],
  "name": "node-persist",
  "optionalDependencies": {},
  "readme": "# node-persist\n## (localStorage on the server)\n\n### Super-easy (and fast) persistent data structures in Node.js, modeled after HTML5 localStorage\nNode-persist doesn't use a database. Instead, JSON documents are stored in the file system for persistence. Because there is no network overhead and your data is just in-memory, node-persist is just about as fast as a database can get. Node-persist uses the HTML5 localStorage API, so it's easy to learn.\n\nThis is still a work in progress. Send pull requests please.\n\n## Install\n\n```sh\n$ npm install node-persist\n```\n\nThen in code you can do: \n\n```js\nvar storage = require('node-persist');\n```\n\n## Basic Example\n\nAsync example\n```js\n//you must first call storage.init\n\nstorage.init( /* options ... */ ).then(function() {\n  //then start using it\n  storage.setItem('name','yourname')\n  .then(function() {\n\n    return storage.getItem('name')\n  })\n  .then(function(value) {\n\n    console.log(value); // yourname\n  })\n});\n\n```\n\nSync example\n```\n//you must first call storage.initSync\nstorage.initSync();\n\n//then start using it\nstorage.setItemSync('name','yourname');\nconsole.log(storage.getItemSync('name')); // yourname\n\n```\n\n## Run the examples:\n\n```sh\n$ cd examples/examplename\n$ node examplename.js\n$ open up localhost:8080\n```\n\n## 2.0.0 change logs\n\nNon-backward changes\n\n* filenames on the file system are now md5 hashed now and the structure of the saved data has changed to include the ttl in them.\n* no longer need/support a `options.ttlDir`, since the `ttls` are now stored in the same file as each value\n* added `expiredInterval` option\n* added `forgiveParseErrors` option\n\n## 1.0.0 change logs\n\nMostly non-backward changes\n\n* `storage.getItem()` now returns a promise\n* `storage.valuesWithKeyMatch()` no longer accepts a callback\n* `storage.values()` no longer accepts a callback\n* `storage.key()` is gone\n* The default `dir` is now `process.cwd() + (dir || '.node-persist/storage')`, unless you use an absolute path\n* added `storage.get()`, alias to `getItem()`\n* added `storage.set()`, alias to `setItem()`\n* added `storage.del()`, `storage.rm()`, as aliases to `removeItem()`\n* Keys, on the file system are base64 encoded with the replacement of the `/`\n\n## API Documentation\n\n#### `init(options, [callback])` - asynchronous*, returns Promise\nThis function reads what's on disk and loads it into memory, if the storage dir is new, it will create it\n##### Options\nYou can pass `init()` or `initSync()` an options object to customize the behavior of node-persist\n\nThese are the defaults\n```js\nstorage.init({\n\tdir: 'relative/path/to/persist',\n\n\tstringify: JSON.stringify,\n\n\tparse: JSON.parse,\n\n\tencoding: 'utf8',\n\n\tlogging: false,  // can also be custom logging function\n\n\tcontinuous: true, // continously persist to disk\n\n\tinterval: false, // milliseconds, persist to disk on an interval\n\n\tttl: false, // ttl* [NEW], can be true for 24h default or a number in MILLISECONDS\n\n\texpiredInterval: 2 * 60 * 1000, // [NEW] every 2 minutes the process will clean-up the expired cache\n\n    // in some cases, you (or some other service) might add non-valid storage files to your\n    // storage dir, i.e. Google Drive, make this true if you'd like to ignore these files and not throw an error\n    forgiveParseErrors: false // [NEW]\n\n}, /* optional callback */ ).then(onSuccess, onError); // or use the promise\n```\n\\* With ttl (time to live), it is recommended that you use `getItem(key, callback)` or `getItemSync(key)` since, if a `ttl` of a certain key is expired the key-file is immediately deleted from disk, the callback will execute whenever that happends, if there is no ttl used or it has expired yet, the callback will also immediately execute in a synchronous fashion.  \n\n##### Node-persist has 3 ways of running:\n\n1. By default, keys will be persisted after every call of setItem\n2. If you set an interval, node-persist will persist changed keys at that interval instead of after every call of setItem.\n3. If you set continuous to false and don't specify an interval, keys aren't persisted automatically, giving you complete control over when to persist them.\n\n#### `initSync(options)` - synchronous, throws Error on failure \nlike `init()` but synchronous,\n\n\n#### `getItem(key, [callback])` - returns promise,\nThis function will get a key from your database in memory\n\n```js\n\n// callback\nstorage.getItem('name', function (err, value) {\n    // use value here after making sure expired-ttl key deletion has occured, in that case value === undefined\n});\n\n// promise\nstorage.getItem('obj').then(function(value) {\n\n})\n\n```\n#### `getItemSync(key)` - returns value\nAll synchronous part along with the deletion of an expired-ttl key, if `options.ttl` is used\n\n#### `setItem(key, value, [options, callback])` - asynchronous*, returns Promise\nThis function sets 'key' in your database to 'value'. It also sets a flag, notifying that 'key' has been changed and needs to be persisted in the next sweep. Because the flag must be set for the object to be persisted, it is best to use node-persist in a functional way, as shown below.\n\n```js\nstorage.setItem('fibonacci',[0,1,1,2,3,5,8]);\nstorage.setItem(42,'the answer to life, the universe, and everything.', function(err) {\n    // done\n});\nstorage.setItem(42,'the answer to life, the universe, and everything.', {ttl: 1000*60 /* 1 min */ }, function(err) {\n    // done\n});\n\nvar batman = storage.getItem('batman');\nbatman.sidekick = 'Robin';\n\n// using the promise\nstorage.setItem('batman', batman).then(\n  function() {\n    // success\n  },\n  function() {\n     // error\n  })\n```\n\\* The only option available when calling `setItem(key, value, option)` is `{ttl: $milliseconds}`\n\n\\* `setItem()` is asynchronous, however, depending on your global options, the item might not persist to disk immediately, in the case where you set `options.interval` or `options.continuous=false`, your (optional) callback or your returned promise from this function will still get resolved immediately, even if the value has not been persisted to disk yet, which could be either waiting for the interval to kick in or for your manual call to `persist()` - kind of how the `redis` database works.\n\n#### `setItemSync(key, value, [options])` - synchronous, throws Error on failure\nIf you want to immediately persist to disk, __regardless of the `this.options.interval` and `this.options.continuous`__ settings, use this function. The only option available when calling `setItemSync(key, value, option)` is `{ttl: $milliseconds}`\n```javascript\nstorage.setItemSync('foo', 'bar');\nstorage.setItemSync('hello', 'world', {ttl: 1000 * 60 /* ttl 1 minute */})\n```\n#### `removeItem(key, [callback])` - asynchronous, returns Promise \nThis function removes key in the database if it is present, and immediately deletes it from the file system asynchronously. If ttl is used, the corrresponding ttl-key is removed as well\n\n```js\nstorage.removeItem('me', /* optional callback */ function(err) {\n  // done \n}).then(onSuccess, onError); // or use the promise\n```\n#### `removeItemSync(key)` - synchronous,  throws Error on failure\njust like removeItem, but synchronous\n```js\nstorage.removeItemSync('me');\n```\n#### `clear([callback])` - asynchronous, returns Promise \nThis function removes all keys in the database, and immediately deletes all keys from the file system asynchronously.\n#### `clearSync()` - synchronous, throws Error on failure\nlike `clear()` but synchronous\n\n#### `values()` -  synchronous, returns array \nThis function returns all of the values in the database in memory. \n\n```js\nstorage.setItem(\"batman\", {name: \"Bruce Wayne\"});\nstorage.setItem(\"superman\", {name: \"Clark Kent\"});\nconsole.log(storage.values()); //output: [{name: \"Bruce Wayne\"},{name: \"Clark Kent\"}]\n```\n#### `values()` - returns array\n\n```js\nvar values = storage.values();\n```\n\n#### `valuesWithKeyMatch(match)` -  synchronous, returns array \nThis function returns all of the values in the database matching a string or RegExp\n\n```js\nstorage.setItem(\"batman\", {name: \"Bruce Wayne\"});\nstorage.setItem(\"superman\", {name: \"Clark Kent\"});\nstorage.setItem(\"hulk\", {name: \"Bruce Banner\"});\nconsole.log(storage.valuesWithKeyMatch('man')); //output: [{name: \"Bruce Wayne\"},{name: \"Clark Kent\"}]\n// also accepts a Regular Expression\nconsole.log(storage.valuesWithKeyMatch(/man/)); //output: [{name: \"Bruce Wayne\"},{name: \"Clark Kent\"}]\n```\n#### `valuesWithKeyMatch(match)` -  synchronous, returns array\n```js\nvar values = storage.valuesWithKeyMatch('man');\n```\n\n#### `keys()` - synchronous, returns array\n\nthis function returns an array of all the keys in the database. This function returns the number of keys stored in the database.\n\n#### `length()` - synchronous, returns number\n\nThis function returns the number of keys stored in the database.\n\n#### `forEach(callback)` - synchronous, assuming callback is as well.\n\nThis function iterates over each key/value pair and executes a callback. \n\n```javascript\nstorage.forEach(function(key, value) {\n\t// use key and value\n});\n```\n\n### Fine-grained control\nMake sure you set `continuous:false` in the `options` hash, and you don't set an `interval`\n\n#### `persist([callback])` - asynchronous, returns Promise \nThese function can be used to manually persist the database\n```js\nstorage.persist( /* optional callback */ function(err) {\n    // when done\n}).then(onSuccess, onError); // or you can use the promise\n```\n#### `persistSync()` - synchronous, throws Error on failure\nlike `persist()` but synchronous\n```js\nstorage.persistSync();\n```\n##### note:\nBoth `persist()`, `persistSync()`, `persistKey()`, and `persistKeySync()` will automatically persist the ttl keys/values in the persistance process\n\n#### `persistKey(key, [callback])` - asynchronous, returns Promise \nThis function manually persist a 'key' within the database\n```js\nstorage.setItem('name','myname');\nstorage.persistKey('name', /* optional callback */ function(err) {\n    // when done\n}).then(onSuccess, onError); // or you can use the promise\n```\n\n#### `persistKeySync(key)`\nlike `persistKey()` but synchronous\n```js\nstorage.setItem('name','myname');\nstorage.persistKeySync('name');\n```\n\n### Factory method\n\n#### `create(options)` - synchronous, static method \n\nIf you choose to create multiple instances of storage, you can. Just avoid using the same `dir` for the storage location.\n__You still have to call `init` or `initSync` after `create`__ - you can pass your configs to either `create` or `init/Sync`\n\nThe reason we don't call `init` in the constructor (or when you `create`) because we can only do so for the `initSync` version, the async `init` returns a promise, and in order to maintain that API, we cannot return the promise in the constructor, so `init` must be called on the instance of new LocalStorage();\n\n```javascript\nvar storage = require('node-persist');\nvar myStorage = storage.create({dir: 'myDir', ttl: 3000});\nmyStorage.init().then(function() { // or you can use initSync()\n   // ...\n});\n```\n\n### Contributing\n\n#### Tests\n\n```\nnpm install\nnpm test\n```\n\n##### [Simon Last](http://simonlast.org)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/simonlast/node-persist.git"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha tests/"
  },
  "version": "2.0.11"
}
